//ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
//ùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùù
//ùùùùùùùùùù°°°°°°°°°°ù°°°°°°°°ùùù°°°°°°°°ùù°°°ùùùù°°°ù°°°°°°°°°°ù°°°°°°°°°ùù
//ùùùùùùùùù°±°ùùùùùùù°±°ùùùù°±°ù°±°ùùùù°±°ù°±°ùùùù°±°ù°±°ùùùùùùùù°±°ùùùù°±°ùù
//ùùùùùùùù±°±ùùùùùùù±°±ùùùùùùùù±°±ùùùùùùùù±°±ùùùù±°±ù±°±ùùùùùùùù±°±ùùùù±°±ùùù
//ùùùùùùù±²±±°±±²ùù±²±±°±±²±±ù±²±ùùùùùùùù±²±±°±±²±±ù±²±±°±±²ùùù±²±±°±±²°ùùùùù
//ùùùùùù±²±ùùùùùùùùùùùùùù±²±ù±²±ùùùùùùùù±²±ùùùù±²±ù±²±ùùùùùùùù±²±ùùùù±²±ùùùùù
//ùùùùù²±²ùùùùùùù²±²ùùùù²±²ù²±²ùùùù²±²ù²±²ùùùù²±²ù²±²ùùùùùùùù²±²ùùùù²±²ùùùùùù
//ùùùù²²²²²²²²²²ù²²²²²²²²ùùù²²²²²²²²ùù²²²ùùùù²²²ù²²²²²²²²²²ù²²²ùùùù²²²ùùùùùùù
//ùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùù
//ùùùùùùùùùùùCopyrightù(c)ù1994-1996ùbyùCharybdisùEnterprises,ùInc.ùùùùùùùùùù
//ùùùùùùùùùùùùùùùùùùùùùùùùùùAllùRightsùReserved.ùùùùùùùùùùùùùùùùùùùùùùùùùùùùù
//ùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùù
//ùùùùùùùùùùùùùùùùùùùùù Microsoft Windows '95 Version ùùùùùùùùùùùùùùùùùùùùùùù
//ùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùùù
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//
//           *** Charybdis Enterprises, Inc. Company Confidential ***
//
//  This file and all associated files are the company proprietary property
//        of Charybdis Enterprises, Inc.  Unauthorized use prohibited.
//
// CHARYBDIS ENTERPRISES, INC. MAKES NO WARRANTIES, EXPRESS OR IMPLIED, AS
// TO THE CORRECTNESS OF THIS CODE OR ANY DERIVATIVE WORKS WHICH INCORPORATE
// IT.  CHARYBDIS ENTERPRISES, INC. PROVIDES THE CODE ON AN "AS-IS" BASIS
// AND EXPLICITLY DISCLAIMS ANY LIABILITY, INCLUDING CONSEQUENTIAL AND
// INCIDENTAL DAMAGES FOR ERRORS, OMISSIONS, AND OTHER PROBLEMS IN THE CODE.
//
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
//
// Created by Tim Little & Chuck Walbourn
//
// essprite.cpp
//
// Contains the code for the EschSprite class which implements
// a 2D bitmap drawable.
//
//ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//
//                                Includes
//                                
//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°

#include "escher.hpp"

//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//
//                                 Data
//
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

extern EschPoint EschTempPoint;

//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//
//                                 Code
//
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±

//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//°°°°°°°°°°°°°°°°°°°°°°±  Constructors/Destructors  ±°°°°°°°°°°°°°°°°°°°°°°°
//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°

//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// EschSprite - Destructor                                                  ³
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
EschSprite::~EschSprite()
{
    release();
};



//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//°°°°°°°°°°°°°°°°°°°°°°°°°°°°±  Operations  ±°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°

//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// EschSprite - draw                                                        ³
//                                                                          ³
// Draws the sprite using the current drawing context.                      ³
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
void EschSprite::draw()
{
    dword           *vflags;
    VngoPoint       *vpt;

    if (!txt)
        return;

    assertMyth("EschSprite::draw needs valid size",
               width > 0 && height > 0);

//ÄÄÄ Clear arena
    ivory_arena_clear(EschSysInstance->wspace);
    
//ÄÄÄ Setup local pointers to current camera and Van Gogh viewport.
    assertMyth("EschSprite::draw needs camera in current context",
               EschCurrent != NULL && EschCurrent->camera != NULL);

    EschCamera *cam=EschCurrent->camera;

    assertMyth("EschSprite::draw needs a viewport in current context's camera",
               cam->vport != NULL);

    dword cflags = cam->flags;
    dword level = cflags & limits;

    assertMyth("EschSprite::draw needs a palette in current context's camera",
               cam->vport->vbuff.pal != NULL);

    int mp = cam->vport->vbuff.pal->shd_pal->mid_point;

//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Transform
    //ÄÄÄ Transform into copy of point
    if (flags & ESCH_SPRITE_INFINITE)
    {
        // If no depth, only account for rotation

        ((EschVector*)&pos)->transform(&cam->eye.iorient,
                                       (EschVector*)&EschTempPoint);
    }
    else
    {
        // Otherwise, perform standard transform and clip of sprite
        // position

        pos.transform(&cam->eye.iorient,&EschTempPoint);

        //ÄÄÄ Clip against view volume

        // Near/far clipping
        if (EschTempPoint.z.flx > cam->yon.flx
            || EschTempPoint.z.flx < cam->hither.flx)
            return;
    }

//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Setup Context
    EschContext ec(EschCurrent);
    ec.current = this;
    ec.verts = 0;
    ec.vflags = vflags = (dword*)ivory_arena_zalloc(EschSysInstance->wspace,sizeof(dword) * 4);
    ec.vpoints = vpt = new (EschSysInstance->wspace) VngoPoint[4];
    ec.faces = new (EschSysInstance->wspace) EschFace[2];
    ec.fflags = 0;
    ec.txts = (EschTexture**) &txt;
    ec.push();

//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Setup Rectangle
//ÄÄÄ Create 4 (transformed) verticies (must rotate about Z for FoR)
//
// 3-----2
// | A   |
// |  *  |
// |   B |
// 0-----1
//
    Flx16 ti = cam->top.i;
    Flx16 tj = cam->top.j;

    Flx16 c = tj / flx_sqrt(ti*ti + tj*tj);
    Flx16 s = flx_sqrt(Flx16(1) - (c*c));
    if (ti < 0)
        s = -s;

    Flx16 wh = Flx16(width.flx >> 1,0);
    Flx16 hh = Flx16(height.flx >> 1,0);

    Flx16 xc = wh*c;
    Flx16 yc = hh*c;

    Flx16 xs = wh*s;
    Flx16 ys = hh*s;

#if 0
    ((EschPoint*)&vpt[0])->x = EschTempPoint.x - wh;
    ((EschPoint*)&vpt[0])->y = EschTempPoint.y - hh;
    ((EschPoint*)&vpt[0])->z = EschTempPoint.z;

    ((EschPoint*)&vpt[1])->x = EschTempPoint.x + wh;
    ((EschPoint*)&vpt[1])->y = EschTempPoint.y - hh;
    ((EschPoint*)&vpt[1])->z = EschTempPoint.z;

    ((EschPoint*)&vpt[2])->x = EschTempPoint.x + wh;
    ((EschPoint*)&vpt[2])->y = EschTempPoint.y + hh;
    ((EschPoint*)&vpt[2])->z = EschTempPoint.z;

    ((EschPoint*)&vpt[3])->x = EschTempPoint.x - wh;
    ((EschPoint*)&vpt[3])->y = EschTempPoint.y + hh;
    ((EschPoint*)&vpt[3])->z = EschTempPoint.z;
#else
    ((EschPoint*)&vpt[0])->x = EschTempPoint.x - xc + ys;
    ((EschPoint*)&vpt[0])->y = EschTempPoint.y - xs - yc;
    ((EschPoint*)&vpt[0])->z = EschTempPoint.z;

    ((EschPoint*)&vpt[1])->x = EschTempPoint.x + xc + ys;
    ((EschPoint*)&vpt[1])->y = EschTempPoint.y + xs - yc;
    ((EschPoint*)&vpt[1])->z = EschTempPoint.z;

    ((EschPoint*)&vpt[2])->x = EschTempPoint.x + xc - ys;
    ((EschPoint*)&vpt[2])->y = EschTempPoint.y + xs + yc;
    ((EschPoint*)&vpt[2])->z = EschTempPoint.z;

    ((EschPoint*)&vpt[3])->x = EschTempPoint.x - xc - ys;
    ((EschPoint*)&vpt[3])->y = EschTempPoint.y - xs + yc;
    ((EschPoint*)&vpt[3])->z = EschTempPoint.z;
#endif

//ÄÄÄ Create 2 faces
    dword fflags = (limits & (ESCH_FACE_WIRE
                              | ESCH_FACE_SOLID
                              | ESCH_FACE_FLAT
                              | ESCH_FACE_TEXTURED))
                              | ESCH_FACE_ABLINE
                              | ESCH_FACE_BCLINE
                              | ESCH_FACE_CALINE;

    ec.faces[0].flags = fflags;
    ec.faces[0].a     = 0;
    ec.faces[0].u[0]  = Flx16(0.01);
    ec.faces[0].v[0]  = Flx16(0.99);
    ec.faces[0].b     = 1;
    ec.faces[0].u[1]  = Flx16(0.99);
    ec.faces[0].v[1]  = Flx16(0.99);
    ec.faces[0].c     = 2;
    ec.faces[0].u[2]  = Flx16(0.99);
    ec.faces[0].v[2]  = Flx16(0.01);
    ec.faces[0].txt   = 1;

    ec.faces[1].flags = fflags;
    ec.faces[1].a     = 0;
    ec.faces[1].u[0]  = Flx16(0.01);
    ec.faces[1].v[0]  = Flx16(0.99);
    ec.faces[1].b     = 2;
    ec.faces[1].u[1]  = Flx16(0.99); 
    ec.faces[1].v[1]  = Flx16(0.01);
    ec.faces[1].c     = 3;
    ec.faces[1].u[2]  = Flx16(0.01);
    ec.faces[1].v[2]  = Flx16(0.01);
    ec.faces[1].txt   = 1;

//ÄÄÄ Handle shading
    vpt[0].clr = 0;
    vpt[0].shade = mp;

    EschLight *lights = EschCurrent->lights;
    if ((level & ESCH_CAM_SHADE_FLAT)
        && !(flags & ESCH_SPRITE_INFINITE)
        && lights)
    {
        EschFrameRef    world;
        world.set_position(&pos);
        lights->setup(&world);

        EschVertex  vtx;

        if (cam->flags & ESCH_CAM_MODELSPACE)
        {
            vtx.x = 0; vtx.y = 0; vtx.z = 0;
            vtx.normal.i = 0;
            vtx.normal.j = 0;
            vtx.normal.k = -1;
        }
        else
        {
            vtx.x = pos.x;
            vtx.y = pos.y;
            vtx.z = pos.z;
            vtx.normal = -cam->eye.dir;
        }

        vpt[0].shade = 0;
        lights->shine(&vtx,&vpt[0],1);
    }

    for(int i=0; i < 4; i++)
    {
        vflags[i] = ESCH_VVERT_TRANSFORMED | ESCH_VVERT_LIT;
        vpt[i].clr = vpt[0].clr;
        vpt[i].shade = vpt[0].shade;
    }
    
//ÄÄÄ Draw Faces
    dword ctrlfl = ESCH_CDF_CLIP
                   | ESCH_CDF_MUSTTXT
                   | ((flags & ESCH_SPRITE_INFINITE) ? ESCH_CDF_INFINITEZ : 0);
    esch_clipdraw_face(0,ctrlfl);
    esch_clipdraw_face(1,ctrlfl);

//ÄÄÄ Pop drawing context
    ec.pop();
}


//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// EschSprite - get_extents                                                 ³
//                                                                          ³
// Returns the extent of the sprite in world coords.                        ³
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
int EschSprite::get_extents(EschSphereExtents *sp) const
{
    if (flags & ESCH_SPRITE_INFINITE)
        return -1;

    assertMyth("EschSprite::get_extents needs return sphere extents",
               sp != 0);

    assertMyth("EschSprite::get_extents needs valid size",
               width > 0 && height > 0);

    sp->center = pos;
    sp->radius = Flx16( ((width > height) ? width : height).flx >> 1,0);

    return 0;
}


//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// EschSprite - animate                                                     ³
//                                                                          ³
// Animates the texture.                                                    ³
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
void EschSprite::animate()
{
    if (!txt)
        return;

    if (!(txt->flags & ESCH_TXT_SKIPANIMATE))
        txt->animate();
}


//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// EschSprite - release                                                     ³
//                                                                          ³
// Releases the sprite data.                                                ³
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
void EschSprite::release()
{
    if (flags & ESCH_DRW_OWNSDATA)
    {
        delete txt;
    }
    txt=0;

    flags &= ~ESCH_DRW_OWNSDATA;
}



//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°
//°°°°°°°°°°°°°°°°°°°°°°°°°°±  Utility Routines  ±°°°°°°°°°°°°°°°°°°°°°°°°°°°
//°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°

//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// EschSprite - attach                                                      ³
//                                                                          ³
// Attaches a texture as a sprite.                                          ³
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
void EschSprite::attach(EschTexture *t)
{
    if (!t)
        return;

    release();

    txt = t;
}


//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
// EschSprite - create                                                      ³
//                                                                          ³
// Creates a sprite from a (appropriate) bitmap.                            ³
//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
esch_error_codes EschSprite::create(XFBitmap *bm, Flx16 w, Flx16 h)
{
//ÄÄÄ Verify valid input
    if (w <= 0 || h <= 0)
        return ESCH_ERR_INVALIDPARMS;

//ÄÄÄ Prepare sprite
    release();

    width=w;
    height=h;

//ÄÄÄ Create texture
    flags |= ESCH_DRW_OWNSDATA;

    txt = new EschStaticTexture;
    if (!txt)
        return ESCH_ERR_NOMEMORY;

    esch_error_codes err=((EschStaticTexture*)txt)->create(bm);
    if (err)
        return err;

    return ESCH_ERR_NONE;
}

//°±² End of module - essprite.cpp ²±°

